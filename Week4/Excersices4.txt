
----------------------------------------------------------------------------------------
DO THIS FIRST
----------------------------------------------------------------------------------------
The exercises build on the lecture note Microbenchmarks note and the accompanying 
example code. Carefully study the hints and warnings in Section 7 of that note before 
you measure anything. NEVER measure anything from inside an IDE or when in Debug mode.
All the Java code listed in the Microbenchmarks note, the lecture and these exercises 
can be found on the Github page for the course 

    https://github.itu.dk/kasper/PCPP-Public

under week 4 in the directory: CodeForBenchmarkNote . - Download these. You will run 
some (or all of) the measurements discussed in the Microbenchmarks note yourself, and 
save results to text files. Use the SystemInfo method to record basic system 
identification, and supplement with whatever other information you can find about your 
execution platform.

    • on Linux you may use cat /proc/cpuinfo; 
    • on MacOS you may use Apple > About this Mac; 
    • on Windows 10 look in the System Information

----------------------------------------------------------------------------------------
Exercise 4.1 
----------------------------------------------------------------------------------------

In this exercise you must perform, on your own hardware, some of the measurements done 
in the Microbenchmarks note.

Green -----------------------------------------------------------------------------------

1.  Run the Mark1 through Mark4 measurements. Include the results in your hand-in, and 
    reflect and comment on them: Are they plausible? Any surprises? Mention any cases 
    where they deviate significantly from those shown in the Microbenchmarks note.

    ANSWER:

    Mark1: Because the count is 20 000 000 which is a high number,  the execution time drops to 0.2 ns which is highly implausible
    Mark2: the result seem reasonable because we removed the Just -in time optimization  by adding a parameter outside of the loop (dummy)
    Mark3: The running times are close to each other and they are close to the measurement in Mark2. Therefore, the result is reasonable.
    Mark4: this calculates the standard deviation. The result looks satisfactory
    



Yellow -----------------------------------------------------------------------------------

2.  Run the Mark1 through Mark5 measurements. Include the results in your hand-in, and 
    reflect and comment on them: Are they plausible? Any surprises? Mention any cases 
    where they deviate significantly from those shown in the Microbenchmarks note.

    ANSWER:
        Mark5: also calculates the standard deviation but prints the different counts.
        No surprises everything runs as in the paper. Even the st deviation is the higher for the count of 2048
        94.2 ns +/-   176.79       2048

----------------------------------------------------------------------------------------
Exercise 4.2 
----------------------------------------------------------------------------------------

In this exercise you will write code for calculating means and standard variation. 

Green -----------------------------------------------------------------------------------
1.  In all the examples in Benchmark.java there are some lines like these: 

            ...
            st += time;
            sst += time * time; 
        }
        double mean = st/n, sdev = Math.sqrt((sst - mean*mean*n)/(n-1)); 
        ...

    Explain what is calculated here and relate to the formulas on the "slide" entitled 
    Variance from the lecture.

    ANSWER: mean = average of all the running times
            sdev = standard deviation, a measure of the amount of varation from a set of values(running times)

    Complete this primitive code for calculating the mean and standard variaton of the 
    numbers in the array a:

        class MeanVar {
            public static void main(String[] args) {
                double[] a=
                    { 30.7, 30.3, 30.1, 30.7, 50.2, 30.4, 30.9, 30.3, 30.5, 30.8 };
                ...
                for (int j= 0; j<n; j++) { 
                    ...
                }
                System.out.printf("%6.1f ns +/- %6.3f%n", mean, sdev); 
            }
        }

    Your hand-in must contain the results of running the completed program.
    Now change the values in a to be: 
    30.7, 30.3, 30.1, 30.7, 50.2, 30.4, 30.9, 30.3, 30.5, 30.8
    30.7, 100.2, 30.1, 30.7, 20.2, 30.4, 2,   30.3, 30.5, 5.4 . 

    Run the program with these numbers and include the results in your hand in.

    ANSWER: See txt file

Yellow ----------------------------------------------------------------------------------

2.  Assume that you include one more observation 25 in the sample (contents of array a). 
    Is 25 an outlier in the first set of numbers? In the second?

    ANSWER: It will be an outlier in the first array beacuse it deviates more than one standard deviation from the norm 
            It will not be an outlier in the second beacuse it deviates less than one standard deviation from the norm.

----------------------------------------------------------------------------------------
Exercise 4.3 
----------------------------------------------------------------------------------------

In this exercise you must perform, on your own hardware, the measurement performed in 
the lecture using the example code in file TestTimeThreads.java.

Green -----------------------------------------------------------------------------------

1.  First compile and run the thread timing code as is, using Mark6, to get a feeling 
    for the variation and robustness of the results. Do not hand in the results but 
    discuss any strangenesses, such as large variation in the time measurements for 
    each case.

    ANSWER: we experienced a jump:
                For the hashcode on count 512
                For the pointCreation on count 64 and 4
                For the Thread's work count 32
                Thread create count 256, 2048
                Thread create start on 1024, 4096
                Thread create start join on 256
                Uncontended lock on 512, 16


Yellow ----------------------------------------------------------------------------------

2.  Now change all the measurements to use Mark7, which reports only the final result. 
    Record the results in a text file along with appropriate system identification.
    Include the results in your hand-in, and reflect and comment on them: 
    Are they plausible? Any surprises? Mention any cases where they deviate significantly 
    from those shown in the lecture.

    ANSWER: The results from using Mark7 is similar to the lowest consistent numbers from using Mark6

----------------------------------------------------------------------------------------
Exercise 4.4 
----------------------------------------------------------------------------------------

In this exercise you must use the benchmarking infrastructure to measure the performance 
of the prime counting example given in file TestCountPrimesThreads.java.


Green ----------------------------------------------------------------------------------- 

1.  Measure the performance of the prime counting example on your own hardware, as a 
    function of the number of threads used to determine whether a given number is a prime. 
    Record system information as well as the measurement results for 1. . . 32 threads in 
    a text file. If the measurements take excessively long time on your computer, you may 
    measure just for 1. . . 16 threads instead.

    ANSWER:

2.  Reflect and comment on the results; are they plausible? Is there any reasonable 
    relation between the number of threads that gave best performance, and the number 
    of cores in the computer you ran the benchmarks on? Any surprises?

    ANSWER: The results show that it does not make sense to have more threads than your machine have cores.

Yellow ----------------------------------------------------------------------------------

3.  Now instead of the LongCounter class, use the 
    java.util.concurrent.atomic.AtomicLong class for the counts. 
    Perform the measurements again as indicated above. Discuss the results: 
    is the performance of AtomicLong better or worse than that of LongCounter? 
    Should one in general use adequate built-in classes and methods when they exist?

    ANSWER: We did not see much of a difference from the result but one should use a built-in class and method when they exists


# OS:   Mac OS X; 10.15.6; x86_64
# JVM:  Oracle Corporation; 11.0.4
# CPU:  null; 8 "cores"
# Date: 2020-09-20T22:24:00+0200
countParallel                     11215,4 us     973,51          2
countParallel                     10975,7 us     141,32          4
countParallel                     10969,7 us      82,21          8
countParallel                     10982,9 us     173,86         16
countParallel                     11799,9 us    1897,54         32

------------
AtomicLong
# OS:   Mac OS X; 10.15.6; x86_64
# JVM:  Oracle Corporation; 11.0.4
# CPU:  null; 8 "cores"
# Date: 2020-09-20T22:21:57+0200
countParallel                     11647,5 us    1055,70          2
countParallel                     10975,3 us      75,30          4
countParallel                     10951,7 us     103,70          8
countParallel                     11072,3 us     210,84         16
countParallel                     10937,5 us     117,03         32

----------------------------------------------------------------------------------------
Exercise 4.5 
----------------------------------------------------------------------------------------

In this exercise, we will analyze the performance of locks ("synchronized"). 
This lambda can be used in the benchmarking code (Benchmark.java)

    "Uncontended lock", 
        i -> {
            synchronized (obj) {
                return i;
            }       
        }

Green ----------------------------------------------------------------------------------- 

1.  Use Mark6 to estimate the cost of getting an uncontended lock on your own hardware. 
    Include the results in your hand-in and comment on them: Are they plausible? 
    Any surprises?

ANSWER: According to our results the estimated cost of getting an uncontended lock is 20,3 ns

----------------------------------------------------------------------------------------    
Exercise4.6 
----------------------------------------------------------------------------------------

This exercise is a follow up on the question asked in the PCPP forum: 
    
    https://learnit.itu.dk/mod/forum/discuss.php?d=24089 . 

    The question arose from measurement on this class:

        class Exp {
            public long volExp (int N) {
                PerfTest pt = new PerfTest(); 
                Long start = System.nanoTime(); 
                for (int i = 0; i < N; i++) {
                    pt.vInc(); 
                }
                return System.nanoTime()-start; 
                }

        public long nonVolExp (int N) { 
            PerfTest pt = new PerfTest(); 
            Long start = System.nanoTime(); 
            for (int i = 0; i < N; i++) {
                pt.inc(); 
            }
            return System.nanoTime()-start; }
        }

        public class PerfTest {
            private volatile int vCtr;
            private int ctr;

            public void vInc () {
                vCtr++;
            }

        public void inc () {
            ctr++;
        }

        public static void main(String[] args) {
            int[] input = {100_000_00,1000_000_00,Integer.MAX_VALUE/10}; 
            System.out.println("***VOLATILE EXPERIMENTS***");
            for (int n : input) {
                System.out.println("N=" + n);
                long vol = new Exp().volExp(n);
                System.out.println("Volatile time: " + vol); 
                System.out.println("Volatile time per iteration: " + (float)
                    vol / n);
            }
            System.out.println("\n"); 
            System.out.println("***NON-VOLATILE EXPERIMENTS***"); 
            for (int n : input) {
                System.out.println("N=" + n);
                long nonVol = new Exp().nonVolExp(n); 
                System.out.println("Non volatile time: " + nonVol); 
                System.out.println("Non Volatile time per iteration: " +
                    (float) nonVol / n); System.out.println("\n");
            } 
        }
    }


The code attempts to measure the performance difference between a volatile int and a normal int.

Green ----------------------------------------------------------------------------------- 

1.  Use Mark6 (fromBendchmark.java) to compare the performance of incrementing a volatile int
    and a normal int. Include the results in your hand-in and comment on them: 
    Are they plausible? Any surprises?

    ANSWER:




